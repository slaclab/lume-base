{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"lume-base","text":"<p>Python base class and common utilities for LUME wrappers</p>"},{"location":"#installing-lume-base","title":"Installing lume-base","text":"<p>Installing <code>lume-base</code> from the <code>conda-forge</code> channel can be achieved by adding <code>conda-forge</code> to your channels with:</p> <pre><code>conda config --add channels conda-forge\n</code></pre> <p>Once the <code>conda-forge</code> channel has been enabled, <code>lume-base</code> can be installed with:</p> <pre><code>conda install lume-base\n</code></pre> <p>It is possible to list all of the versions of <code>lume-base</code> available on your platform with:</p> <pre><code>conda search lume-base --channel conda-forge\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>This package was developed with the goal of avoid repeating boilerplate code and establish a common interface for LUME compatible codes.</p> <p>The following interfaces are available:</p> <ul> <li> <p>lume.base.Base</p> </li> <li> <p>lume.base.CommandWrapper</p> </li> </ul> <p>The <code>Base</code> class is to be inherited by wrappers which are pure Python and do not invoke an external command. If you would like to provide a LUME compatible interface for a code which wraps an external program, please use the <code>CommandWrapper</code> described below.</p>"},{"location":"architecture/#base","title":"Base","text":"<p>The LUME Base class provides many useful methods which can be examined on the API section of this documentation. The following are abstract methods which must be implemented by you when inheriting from <code>Base</code>:</p> <ul> <li><code>configure</code>: Configure and set up for run.</li> <li><code>run</code>: Execute the code.</li> </ul>"},{"location":"architecture/#command-wrapper","title":"Command Wrapper","text":"<p>The LUME <code>CommandWrapper</code> extends the <code>Base</code> class and provides the following abstract methods, in addition to the ones provided by the <code>Base</code> class, which must be implemented by you:</p> <ul> <li><code>archive</code>: Dump inputs and outputs into HDF5 file.</li> <li><code>load_archive</code>: Loads input and output from archived h5 file.</li> <li><code>plot</code>: Plots output multiple keys.</li> <li><code>write_input</code>: Write the input parameters into the file.</li> <li><code>input_parser</code>: Invoke the specialized input parser and returns the input dictionary.</li> <li><code>load_output</code>: Reads and load into <code>.output</code> the outputs generated by the code.</li> </ul>"},{"location":"architecture/#next-steps","title":"Next Steps","text":"<p>The following sections will describe in detail the available interfaces as well as their properties.</p>"},{"location":"api/base/","title":"Base","text":""},{"location":"api/base/#lume.base.Base","title":"<code>lume.base.Base</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Base Interface for LUME-compatible code.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str, optional</code> <p>The input file to be used, by default None</p> <code>None</code> <code>initial_particles</code> <code>dict, optional</code> <p>Initial Particle metadata to be used, by default None</p> <code>None</code> <code>verbose</code> <code>bool, optional</code> <p>Whether or not to produce verbose output, by default False</p> <code>False</code> <code>timeout</code> <code>float, optional</code> <p>The timeout in seconds to be used, by default None</p> <code>None</code> Source code in <code>lume/base.py</code> <pre><code>class Base(ABC):\n\"\"\"\n    Base Interface for LUME-compatible code.\n\n    Parameters\n    ----------\n    input_file : str, optional\n        The input file to be used, by default None\n    initial_particles : dict, optional\n        Initial Particle metadata to be used, by default None\n    verbose : bool, optional\n        Whether or not to produce verbose output, by default False\n    timeout : float, optional\n        The timeout in seconds to be used, by default None\n    \"\"\"\n\n    def __init__(\n            self, input_file=None, *, initial_particles=None,\n            verbose=False, timeout=None, **kwargs):\n\n        self._input_file = input_file\n        self._initial_particles = initial_particles\n        self._input = None\n        self._output = None\n\n        # Execution\n        self._timeout = timeout\n\n        # Logging\n        self._verbose = verbose\n\n        # State\n        self._configured = False\n        self._finished = False\n        self._error = False\n\n    @property\n    def input(self):\n\"\"\"\n        Input data as a dictionary\n        \"\"\"\n        return self._input\n\n    @input.setter\n    def input(self, input):\n        self._input = input\n\n    @property\n    def output(self):\n\"\"\"\n        require openPMD standard, in the future we can add more methods\n        for libs such as pandas Dataframes, xarray DataArrays and Dask Arrays.\n        \"\"\"\n        return self._output\n\n    @output.setter\n    def output(self, output):\n        self._output = output\n\n    @property\n    def initial_particles(self):\n\"\"\"\n        Initial Particles\n        \"\"\"\n        return self._initial_particles\n\n    @initial_particles.setter\n    def initial_particles(self, initial_particles):\n        self._initial_particles = initial_particles\n\n    @abstractmethod\n    def configure(self):\n\"\"\"\n        Configure and set up for run.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def run(self):\n\"\"\"\n        Execute the code.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def verbose(self):\n\"\"\"\n        Read or configure the verbose flag.\n        \"\"\"\n        return self._verbose\n\n    @verbose.setter\n    def verbose(self, verbose):\n        self._verbose = verbose\n\n    @property\n    def timeout(self):\n\"\"\"\n        Read or configure the timeout in seconds.\n        \"\"\"\n        return self._timeout\n\n    @timeout.setter\n    def timeout(self, timeout):\n        self._timeout = timeout\n\n    @property\n    def configured(self):\n\"\"\"\n        Get or set the configured flag state.\n        \"\"\"\n        return self._configured\n\n    @configured.setter\n    def configured(self, configured):\n        self._configured = configured\n\n    @property\n    def finished(self):\n\"\"\"\n        Get or set the finished flag state.\n        \"\"\"\n        return self._finished\n\n    @finished.setter\n    def finished(self, finished):\n        self._finished = finished\n\n    @property\n    def error(self):\n\"\"\"\n        Get or set the error flag state.\n        \"\"\"\n        return self._error\n\n    @error.setter\n    def error(self, error):\n        self._error = error\n\n    @property\n    def input_file(self):\n\"\"\"\n        Get or set the input file to be processed.\n        \"\"\"\n        return self._input_file\n\n    @input_file.setter\n    def input_file(self, input_file):\n\"\"\"dictionary with parameters?\"\"\"\n        self._input_file = input_file\n\n    def fingerprint(self):\n\"\"\"\n        Data fingerprint (hash) using the input parameters.\n\n        Returns\n        -------\n        fingerprint : str\n            The hash for this object based on the input parameters.\n        \"\"\"\n        return tools.fingerprint(self.input)\n\n    def copy(self):\n\"\"\"\n        Returns a deep copy of this object.\n\n        If a tempdir is being used, will clear this and deconfigure.\n        \"\"\"\n        other = copy.deepcopy(self)\n        other.reset()\n        return other\n\n    def reset(self):\n\"\"\"\n        Reset this object to its initial state.\n        \"\"\"\n        pass\n\n    def vprint(self, *args, **kwargs):\n        # Verbose print\n        if self._verbose:\n            print(*args, **kwargs)\n\n    @classmethod\n    def from_yaml(cls, yaml_file, parse_input=False):\n\"\"\"\n        Returns an object instantiated from a YAML config file\n\n        Will load intial_particles from an h5 file.\n\n        \"\"\"\n        # Try file\n        if os.path.exists(tools.full_path(yaml_file)):\n            yaml_file = tools.full_path(yaml_file)\n            config = yaml.safe_load(open(yaml_file))\n\n            if 'input_file' in config:\n\n                # Check that the input file is absolute path...\n                # require absolute/ relative to working dir for model input file\n                f = os.path.expandvars(config['input_file'])\n                if not os.path.isabs(f):\n                    # Get the yaml file root\n                    root, _ = os.path.split(tools.full_path(yaml_file))\n                    config['input_file'] = os.path.join(root, f)\n\n                # Here, we update the config with the input_file contents\n                # provided that the input_parser method has been implemented on the subclass\n                if parse_input:\n                    parsed_input = cls.input_parser(config['input_file'])\n                    config.update(parsed_input)\n\n\n        else:\n            # Try raw string\n            config = yaml.safe_load(yaml_file)\n            if parse_input and \"input_file\" in config:\n                parsed_input = cls.input_parser(config['input_file'])\n                config.update(parsed_input)\n\n        # Form ParticleGroup from file\n        if 'initial_particles' in config:\n            f = config['initial_particles']\n            if not os.path.isabs(f):\n                root, _ = os.path.split(tools.full_path(yaml_file))\n                f = os.path.join(root, f)\n            config['initial_particles'] = ParticleGroup(f)\n\n        return cls(**config)\n\n    def to_hdf5(self, filename: str) -&gt; None:\n\"\"\"Serialize an object to an hdf5 file.\n\n        Parameters\n        ----------\n        filename: str\n\n        \"\"\"\n        serializer = HDF5Serializer()\n        serializer.serialize(filename, self)\n\n    @classmethod\n    def from_hdf5(cls, filename: str) -&gt; \"Base\":\n\"\"\"Load an object from and hdf5. \n\n        Parameters\n        ----------\n        filename: str\n\n        \"\"\"\n        serializer = HDF5Serializer()\n        return serializer.deserialize(filename)\n\n    @abstractmethod\n    def archive(self, h5=None):\n\"\"\"\n        Dump inputs and outputs into HDF5 file.\n\n        Parameters\n        ----------\n        h5 : str or h5py.File\n            The filename or handle to HDF5 file in which to write the information.\n            If not in informed, a new file is generated.\n\n        Returns\n        -------\n        h5 : h5py.File\n            Handle to the HDF5 file.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def load_archive(self, h5, configure=True):\n\"\"\"\n        Loads input and output from archived h5 file.\n\n        Parameters\n        ----------\n        h5 : str or h5py.File\n            The filename or handle on h5py.File from which to load input and output data\n        configure : bool, optional\n            Whether or not to invoke the configure method after loading, by default True\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api/base/#lume.base.Base.configured","title":"<code>configured</code>  <code>writable</code> <code>property</code>","text":"<p>Get or set the configured flag state.</p>"},{"location":"api/base/#lume.base.Base.error","title":"<code>error</code>  <code>writable</code> <code>property</code>","text":"<p>Get or set the error flag state.</p>"},{"location":"api/base/#lume.base.Base.finished","title":"<code>finished</code>  <code>writable</code> <code>property</code>","text":"<p>Get or set the finished flag state.</p>"},{"location":"api/base/#lume.base.Base.initial_particles","title":"<code>initial_particles</code>  <code>writable</code> <code>property</code>","text":"<p>Initial Particles</p>"},{"location":"api/base/#lume.base.Base.input","title":"<code>input</code>  <code>writable</code> <code>property</code>","text":"<p>Input data as a dictionary</p>"},{"location":"api/base/#lume.base.Base.input_file","title":"<code>input_file</code>  <code>writable</code> <code>property</code>","text":"<p>Get or set the input file to be processed.</p>"},{"location":"api/base/#lume.base.Base.output","title":"<code>output</code>  <code>writable</code> <code>property</code>","text":"<p>require openPMD standard, in the future we can add more methods for libs such as pandas Dataframes, xarray DataArrays and Dask Arrays.</p>"},{"location":"api/base/#lume.base.Base.timeout","title":"<code>timeout</code>  <code>writable</code> <code>property</code>","text":"<p>Read or configure the timeout in seconds.</p>"},{"location":"api/base/#lume.base.Base.verbose","title":"<code>verbose</code>  <code>writable</code> <code>property</code>","text":"<p>Read or configure the verbose flag.</p>"},{"location":"api/base/#lume.base.Base.archive","title":"<code>archive(h5=None)</code>  <code>abstractmethod</code>","text":"<p>Dump inputs and outputs into HDF5 file.</p> <p>Parameters:</p> Name Type Description Default <code>h5</code> <code>str or h5py.File</code> <p>The filename or handle to HDF5 file in which to write the information. If not in informed, a new file is generated.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>h5</code> <code>h5py.File</code> <p>Handle to the HDF5 file.</p> Source code in <code>lume/base.py</code> <pre><code>@abstractmethod\ndef archive(self, h5=None):\n\"\"\"\n    Dump inputs and outputs into HDF5 file.\n\n    Parameters\n    ----------\n    h5 : str or h5py.File\n        The filename or handle to HDF5 file in which to write the information.\n        If not in informed, a new file is generated.\n\n    Returns\n    -------\n    h5 : h5py.File\n        Handle to the HDF5 file.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/base/#lume.base.Base.configure","title":"<code>configure()</code>  <code>abstractmethod</code>","text":"<p>Configure and set up for run.</p> Source code in <code>lume/base.py</code> <pre><code>@abstractmethod\ndef configure(self):\n\"\"\"\n    Configure and set up for run.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/base/#lume.base.Base.copy","title":"<code>copy()</code>","text":"<p>Returns a deep copy of this object.</p> <p>If a tempdir is being used, will clear this and deconfigure.</p> Source code in <code>lume/base.py</code> <pre><code>def copy(self):\n\"\"\"\n    Returns a deep copy of this object.\n\n    If a tempdir is being used, will clear this and deconfigure.\n    \"\"\"\n    other = copy.deepcopy(self)\n    other.reset()\n    return other\n</code></pre>"},{"location":"api/base/#lume.base.Base.fingerprint","title":"<code>fingerprint()</code>","text":"<p>Data fingerprint (hash) using the input parameters.</p> <p>Returns:</p> Name Type Description <code>fingerprint</code> <code>str</code> <p>The hash for this object based on the input parameters.</p> Source code in <code>lume/base.py</code> <pre><code>def fingerprint(self):\n\"\"\"\n    Data fingerprint (hash) using the input parameters.\n\n    Returns\n    -------\n    fingerprint : str\n        The hash for this object based on the input parameters.\n    \"\"\"\n    return tools.fingerprint(self.input)\n</code></pre>"},{"location":"api/base/#lume.base.Base.from_hdf5","title":"<code>from_hdf5(filename)</code>  <code>classmethod</code>","text":"<p>Load an object from and hdf5. </p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> required Source code in <code>lume/base.py</code> <pre><code>@classmethod\ndef from_hdf5(cls, filename: str) -&gt; \"Base\":\n\"\"\"Load an object from and hdf5. \n\n    Parameters\n    ----------\n    filename: str\n\n    \"\"\"\n    serializer = HDF5Serializer()\n    return serializer.deserialize(filename)\n</code></pre>"},{"location":"api/base/#lume.base.Base.from_yaml","title":"<code>from_yaml(yaml_file, parse_input=False)</code>  <code>classmethod</code>","text":"<p>Returns an object instantiated from a YAML config file</p> <p>Will load intial_particles from an h5 file.</p> Source code in <code>lume/base.py</code> <pre><code>@classmethod\ndef from_yaml(cls, yaml_file, parse_input=False):\n\"\"\"\n    Returns an object instantiated from a YAML config file\n\n    Will load intial_particles from an h5 file.\n\n    \"\"\"\n    # Try file\n    if os.path.exists(tools.full_path(yaml_file)):\n        yaml_file = tools.full_path(yaml_file)\n        config = yaml.safe_load(open(yaml_file))\n\n        if 'input_file' in config:\n\n            # Check that the input file is absolute path...\n            # require absolute/ relative to working dir for model input file\n            f = os.path.expandvars(config['input_file'])\n            if not os.path.isabs(f):\n                # Get the yaml file root\n                root, _ = os.path.split(tools.full_path(yaml_file))\n                config['input_file'] = os.path.join(root, f)\n\n            # Here, we update the config with the input_file contents\n            # provided that the input_parser method has been implemented on the subclass\n            if parse_input:\n                parsed_input = cls.input_parser(config['input_file'])\n                config.update(parsed_input)\n\n\n    else:\n        # Try raw string\n        config = yaml.safe_load(yaml_file)\n        if parse_input and \"input_file\" in config:\n            parsed_input = cls.input_parser(config['input_file'])\n            config.update(parsed_input)\n\n    # Form ParticleGroup from file\n    if 'initial_particles' in config:\n        f = config['initial_particles']\n        if not os.path.isabs(f):\n            root, _ = os.path.split(tools.full_path(yaml_file))\n            f = os.path.join(root, f)\n        config['initial_particles'] = ParticleGroup(f)\n\n    return cls(**config)\n</code></pre>"},{"location":"api/base/#lume.base.Base.load_archive","title":"<code>load_archive(h5, configure=True)</code>  <code>abstractmethod</code>","text":"<p>Loads input and output from archived h5 file.</p> <p>Parameters:</p> Name Type Description Default <code>h5</code> <code>str or h5py.File</code> <p>The filename or handle on h5py.File from which to load input and output data</p> required <code>configure</code> <code>bool, optional</code> <p>Whether or not to invoke the configure method after loading, by default True</p> <code>True</code> Source code in <code>lume/base.py</code> <pre><code>@abstractmethod\ndef load_archive(self, h5, configure=True):\n\"\"\"\n    Loads input and output from archived h5 file.\n\n    Parameters\n    ----------\n    h5 : str or h5py.File\n        The filename or handle on h5py.File from which to load input and output data\n    configure : bool, optional\n        Whether or not to invoke the configure method after loading, by default True\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/base/#lume.base.Base.reset","title":"<code>reset()</code>","text":"<p>Reset this object to its initial state.</p> Source code in <code>lume/base.py</code> <pre><code>def reset(self):\n\"\"\"\n    Reset this object to its initial state.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/base/#lume.base.Base.run","title":"<code>run()</code>  <code>abstractmethod</code>","text":"<p>Execute the code.</p> Source code in <code>lume/base.py</code> <pre><code>@abstractmethod\ndef run(self):\n\"\"\"\n    Execute the code.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/base/#lume.base.Base.to_hdf5","title":"<code>to_hdf5(filename)</code>","text":"<p>Serialize an object to an hdf5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> required Source code in <code>lume/base.py</code> <pre><code>def to_hdf5(self, filename: str) -&gt; None:\n\"\"\"Serialize an object to an hdf5 file.\n\n    Parameters\n    ----------\n    filename: str\n\n    \"\"\"\n    serializer = HDF5Serializer()\n    serializer.serialize(filename, self)\n</code></pre>"},{"location":"api/command_wrapper/","title":"CommandWrapper","text":""},{"location":"api/command_wrapper/#lume.base.CommandWrapper","title":"<code>lume.base.CommandWrapper</code>","text":"<p>         Bases: <code>Base</code></p> <p>Interface for LUME-compatible code.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str, optional</code> <p>The input file to be used, by default None</p> <code>None</code> <code>initial_particles</code> <code>dict, optional</code> <p>Initial Particle metadata to be used, by default None</p> <code>None</code> <code>command</code> <code>str, optional</code> <p>The command to be executed by this wrapper. E.g. ImpactTexe If not specified, the class attribute <code>COMMAND</code> is used, by default None</p> <code>None</code> <code>command_mpi</code> <code>str, optional</code> <p>The command to be executed by this wrapper when using MPI. E.g. ImpactTexe-mpi If not specified, the class attribute <code>COMMAND_MPI</code> is used, by default None</p> <code>None</code> <code>use_mpi</code> <code>bool, optional</code> <p>Whether or not to use MPI when running this code, by default False</p> <code>False</code> <code>mpi_run</code> <code>str, optional</code> <p>The command syntax to invoke mpirun. If not specified, the class attribute <code>MPI_RUN</code> is used. This is expected to be a formated string taking as parameters the number of processors (nproc) and the command to be executed (command_mpi), by default None</p> <code>''</code> <code>use_temp_dir</code> <code>bool, optional</code> <p>Whether or not to use a temporary directory to run the process, by default True</p> <code>True</code> <code>workdir</code> <code>str, optional</code> <p>The work directory to be used, by default None</p> <code>None</code> <code>verbose</code> <code>bool, optional</code> <p>Whether or not to produce verbose output, by default False</p> <code>False</code> <code>timeout</code> <code>float, optional</code> <p>The timeout in seconds to be used, by default None</p> <code>None</code> Source code in <code>lume/base.py</code> <pre><code>class CommandWrapper(Base):\n\"\"\"\n    Interface for LUME-compatible code.\n\n    Parameters\n    ----------\n    input_file : str, optional\n        The input file to be used, by default None\n    initial_particles : dict, optional\n        Initial Particle metadata to be used, by default None\n    command : str, optional\n        The command to be executed by this wrapper. E.g. ImpactTexe\n        If not specified, the class attribute `COMMAND` is used, by default None\n    command_mpi : str, optional\n        The command to be executed by this wrapper when using MPI. E.g. ImpactTexe-mpi\n        If not specified, the class attribute `COMMAND_MPI` is used, by default None\n    use_mpi : bool, optional\n        Whether or not to use MPI when running this code, by default False\n    mpi_run : str, optional\n        The command syntax to invoke mpirun. If not specified, the class attribute `MPI_RUN` is used.\n        This is expected to be a formated string taking as parameters the number of processors (nproc) and\n        the command to be executed (command_mpi), by default None\n    use_temp_dir : bool, optional\n        Whether or not to use a temporary directory to run the process, by default True\n    workdir : str, optional\n        The work directory to be used, by default None\n    verbose : bool, optional\n        Whether or not to produce verbose output, by default False\n    timeout : float, optional\n        The timeout in seconds to be used, by default None\n    \"\"\"\n\n    COMMAND = \"\"\n    COMMAND_MPI = \"\"\n    MPI_RUN = \"mpirun -n {nproc} {command_mpi}\"\n\n    def __init__(\n            self, input_file=None, *, initial_particles=None,\n            command=None, command_mpi=None, use_mpi=False, mpi_run=\"\",\n            use_temp_dir=True, workdir=None,\n            verbose=False, timeout=None):\n        super().__init__(\n            input_file=input_file, initial_particles=initial_particles, verbose=verbose, timeout=timeout\n        )\n        # Execution\n        self._command = command or self.COMMAND\n        self._command_mpi = command_mpi or self.COMMAND_MPI\n        self._use_mpi = use_mpi\n        self._mpi_run = mpi_run or self.MPI_RUN\n\n        self._tempdir = None\n        self._use_temp_dir = use_temp_dir\n        self._workdir = workdir\n\n        self._base_path = None\n\n    @property\n    def use_mpi(self):\n\"\"\"\n        Whether or not MPI should be used if supported.\n        \"\"\"\n        return self._use_mpi\n\n    @use_mpi.setter\n    def use_mpi(self, use_mpi):\n        self._use_mpi = use_mpi\n\n    @property\n    def mpi_run(self):\n\"\"\"\n        The command syntax to invoke mpirun. If not specified, the class attribute `MPI_RUN` is used.\n        This is expected to be a formated string taking as parameters the number of processors (nproc) and\n        the command to be executed (command_mpi).\n        \"\"\"\n        return self._mpi_run\n\n    @mpi_run.setter\n    def mpi_run(self, mpi_run):\n        self._mpi_run = mpi_run\n\n    @property\n    def path(self):\n\"\"\"\n        The base path used by the code to manipulate files.\n        \"\"\"\n        return self._base_path\n\n    @path.setter\n    def path(self, path):\n        self._base_path = path\n\n    @property\n    def use_temp_dir(self):\n\"\"\"\n        Whether or not the code is using temporary dir to run.\n\n        Returns\n        -------\n        bool\n        \"\"\"\n        return self._use_temp_dir\n\n    @property\n    def command(self):\n\"\"\"\n        Get or set the command to be executed. Defaults to `COMMAND`.\n        \"\"\"\n        return self._command\n\n    @command.setter\n    def command(self, command):\n        cmd = command\n        if command:\n            cmd = tools.full_path(command)\n            assert os.path.exists(cmd), 'ERROR: Command does not exist:' + command\n        self._command = cmd\n\n    @property\n    def command_mpi(self):\n\"\"\"\n        Get or set the command to be executed when running with MPI. Defaults to `COMMAND_MPI`.\n        \"\"\"\n        return self._command_mpi\n\n    @command_mpi.setter\n    def command_mpi(self, command_mpi):\n        cmd = command_mpi\n        if command_mpi:\n            cmd = tools.full_path(command_mpi)\n            assert os.path.exists(cmd), 'ERROR: Command does not exist:' + command_mpi\n        self._command_mpi = cmd\n\n    def get_run_script(self, write_to_path=True):\n\"\"\"\n        Assembles the run script. Optionally writes a file 'run' with this line to path.\n\n        This expect to run with .path as the cwd.\n\n        Parameters\n        ----------\n        write_to_path : bool\n            Whether or not to write the script to the path.\n\n        Returns\n        -------\n        runscript : str\n            The script to run the command.\n        \"\"\"\n        _, infile = os.path.split(self.input_file)  # Expect to run locally. Astra has problems with long paths.\n\n        runscript = [self.command, infile]\n\n        if write_to_path:\n            with open(os.path.join(self.path, 'run'), 'w') as f:\n                f.write(' '.join(runscript))\n\n        return runscript\n\n    @classmethod\n    def from_archive(cls, archive_h5):\n\"\"\"\n        Class method to return a new instance via restore of an archive file.\n\n        Parameters\n        ----------\n        archive_h5 : str or h5py.File\n            The filename or handle to HDF5 file in which to write the information.\n\n        Returns\n        -------\n        c : object\n            An instance of the class with information from the archive file.\n        \"\"\"\n        c = cls()\n        c.load_archive(archive_h5)\n        return c\n\n    @abstractmethod\n    def plot(self, y=[], x=None, xlim=None, ylim=None, ylim2=None, y2=[], nice=True,\n             include_layout=True, include_labels=False, include_particles=True, include_legend=True,\n             return_figure=False):\n\"\"\"\n        Plots output multiple keys.\n\n        Parameters\n        ----------\n        y : list\n            List of keys to be displayed on the Y axis\n        x : str\n            Key to be displayed as X axis\n        xlim : list\n            Limits for the X axis\n        ylim : list\n            Limits for the Y axis\n        ylim2 : list\n            Limits for the secondary Y axis\n        y2 : list\n            List of keys to be displayed on the secondary Y axis\n        nice : bool\n            Whether or not a nice SI prefix and scaling will be used to\n            make the numbers reasonably sized. Default: True\n        include_layout : bool\n            Whether or not to include a layout plot at the bottom. Default: True\n        include_labels : bool\n            Whether or not the layout will include element labels. Default: False\n        include_particles : bool\n            Whether or not to plot the particle statistics as dots. Default: True\n        include_legend : bool\n            Whether or not the plot should include the legend. Default: True\n        return_figure : bool\n            Whether or not to return the figure object for further manipulation.\n            Default: True\n        kwargs : dict\n            Extra arguments can be passed to the specific plotting function.\n\n        Returns\n        -------\n        fig : matplotlib.pyplot.figure.Figure\n            The plot figure for further customizations or `None` if `return_figure` is set to False.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def write_input(self, input_filename):\n\"\"\"\n        Write the input parameters into the file.\n\n        Parameters\n        ----------\n        input_filename : str\n            The file in which to write the input parameters\n        \"\"\"\n        raise NotImplementedError\n\n\n    @staticmethod\n    @abstractmethod\n    def input_parser(path):\n\"\"\"\n        Invoke the specialized input parser and returns the\n        input dictionary.\n\n        Parameters\n        ----------\n        path : str\n            Path to the input file\n\n        Returns\n        -------\n        input : dict\n            The input dictionary\n        \"\"\"\n        raise NotImplementedError\n\n    def load_input(self, input_filepath, **kwargs):\n\"\"\"\n        Invoke the `input_parser` with the given input file path as argument.\n        This method sets the input property to the contents of the input file after the parser.\n\n        Parameters\n        ----------\n        input_filepath : str\n            The input file path\n        kwargs : dict\n            Support for extra arguments.\n        \"\"\"\n        f = tools.full_path(input_filepath)\n        self.original_path, self.original_input_file = os.path.split(f)  # Get original path, filename\n        self.input = self.input_parser(f)\n\n    @abstractmethod\n    def load_output(self, **kwargs):\n\"\"\"\n        Reads and load into `.output` the outputs generated by the code.\n        \"\"\"\n        raise NotImplementedError\n\n    def reset(self):\n\"\"\"\n        Reset this object to its initial state.\n        \"\"\"\n        super().reset()\n        # Clear this\n        if self._use_temp_dir:\n            self._base_path = None\n            self._configured = False\n\n\n    @property \n    def workdir(self):\n\"\"\"\n        Get or set the working directory\n        \"\"\"\n        return self._workdir\n\n    @workdir.setter\n    def workdir(self, workdir):\n        workdir = full_path(workdir)\n        self.setup_workdir(workdir)\n\n\n    def setup_workdir(self, workdir, cleanup=True):\n\"\"\"\n        Set up the work directory if `use_temp_dir` is set.\n\n        workdir and use_temp_dir: Set up temorary directory inside workdir\n\n        Parameters\n        ----------\n        workdir : str\n            The directory name.\n        cleanup : bool\n            Whether or not to remove the directory at exit. Defaults to True.\n        \"\"\"\n\n        if not cleanup:\n             warnings.warn(\"cleanup option has been removed\", DeprecationWarning)\n\n        # Set paths\n        if self._use_temp_dir:\n            # Need to attach this to the object. Otherwise it will go out of scope.\n            self._tempdir = tempfile.TemporaryDirectory(dir=workdir)\n            self._base_path = self._tempdir.name\n        elif workdir:\n            self._base_path = workdir\n        else:\n            # Work in place\n            self._base_path = self.original_path\n</code></pre>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.command","title":"<code>command</code>  <code>writable</code> <code>property</code>","text":"<p>Get or set the command to be executed. Defaults to <code>COMMAND</code>.</p>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.command_mpi","title":"<code>command_mpi</code>  <code>writable</code> <code>property</code>","text":"<p>Get or set the command to be executed when running with MPI. Defaults to <code>COMMAND_MPI</code>.</p>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.mpi_run","title":"<code>mpi_run</code>  <code>writable</code> <code>property</code>","text":"<p>The command syntax to invoke mpirun. If not specified, the class attribute <code>MPI_RUN</code> is used. This is expected to be a formated string taking as parameters the number of processors (nproc) and the command to be executed (command_mpi).</p>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.path","title":"<code>path</code>  <code>writable</code> <code>property</code>","text":"<p>The base path used by the code to manipulate files.</p>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.use_mpi","title":"<code>use_mpi</code>  <code>writable</code> <code>property</code>","text":"<p>Whether or not MPI should be used if supported.</p>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.use_temp_dir","title":"<code>use_temp_dir</code>  <code>property</code>","text":"<p>Whether or not the code is using temporary dir to run.</p> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.workdir","title":"<code>workdir</code>  <code>writable</code> <code>property</code>","text":"<p>Get or set the working directory</p>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.from_archive","title":"<code>from_archive(archive_h5)</code>  <code>classmethod</code>","text":"<p>Class method to return a new instance via restore of an archive file.</p> <p>Parameters:</p> Name Type Description Default <code>archive_h5</code> <code>str or h5py.File</code> <p>The filename or handle to HDF5 file in which to write the information.</p> required <p>Returns:</p> Name Type Description <code>c</code> <code>object</code> <p>An instance of the class with information from the archive file.</p> Source code in <code>lume/base.py</code> <pre><code>@classmethod\ndef from_archive(cls, archive_h5):\n\"\"\"\n    Class method to return a new instance via restore of an archive file.\n\n    Parameters\n    ----------\n    archive_h5 : str or h5py.File\n        The filename or handle to HDF5 file in which to write the information.\n\n    Returns\n    -------\n    c : object\n        An instance of the class with information from the archive file.\n    \"\"\"\n    c = cls()\n    c.load_archive(archive_h5)\n    return c\n</code></pre>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.get_run_script","title":"<code>get_run_script(write_to_path=True)</code>","text":"<p>Assembles the run script. Optionally writes a file 'run' with this line to path.</p> <p>This expect to run with .path as the cwd.</p> <p>Parameters:</p> Name Type Description Default <code>write_to_path</code> <code>bool</code> <p>Whether or not to write the script to the path.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>runscript</code> <code>str</code> <p>The script to run the command.</p> Source code in <code>lume/base.py</code> <pre><code>def get_run_script(self, write_to_path=True):\n\"\"\"\n    Assembles the run script. Optionally writes a file 'run' with this line to path.\n\n    This expect to run with .path as the cwd.\n\n    Parameters\n    ----------\n    write_to_path : bool\n        Whether or not to write the script to the path.\n\n    Returns\n    -------\n    runscript : str\n        The script to run the command.\n    \"\"\"\n    _, infile = os.path.split(self.input_file)  # Expect to run locally. Astra has problems with long paths.\n\n    runscript = [self.command, infile]\n\n    if write_to_path:\n        with open(os.path.join(self.path, 'run'), 'w') as f:\n            f.write(' '.join(runscript))\n\n    return runscript\n</code></pre>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.input_parser","title":"<code>input_parser(path)</code>  <code>staticmethod</code> <code>abstractmethod</code>","text":"<p>Invoke the specialized input parser and returns the input dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the input file</p> required <p>Returns:</p> Name Type Description <code>input</code> <code>dict</code> <p>The input dictionary</p> Source code in <code>lume/base.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef input_parser(path):\n\"\"\"\n    Invoke the specialized input parser and returns the\n    input dictionary.\n\n    Parameters\n    ----------\n    path : str\n        Path to the input file\n\n    Returns\n    -------\n    input : dict\n        The input dictionary\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.load_input","title":"<code>load_input(input_filepath, **kwargs)</code>","text":"<p>Invoke the <code>input_parser</code> with the given input file path as argument. This method sets the input property to the contents of the input file after the parser.</p> <p>Parameters:</p> Name Type Description Default <code>input_filepath</code> <code>str</code> <p>The input file path</p> required <code>kwargs</code> <code>dict</code> <p>Support for extra arguments.</p> <code>{}</code> Source code in <code>lume/base.py</code> <pre><code>def load_input(self, input_filepath, **kwargs):\n\"\"\"\n    Invoke the `input_parser` with the given input file path as argument.\n    This method sets the input property to the contents of the input file after the parser.\n\n    Parameters\n    ----------\n    input_filepath : str\n        The input file path\n    kwargs : dict\n        Support for extra arguments.\n    \"\"\"\n    f = tools.full_path(input_filepath)\n    self.original_path, self.original_input_file = os.path.split(f)  # Get original path, filename\n    self.input = self.input_parser(f)\n</code></pre>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.load_output","title":"<code>load_output(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Reads and load into <code>.output</code> the outputs generated by the code.</p> Source code in <code>lume/base.py</code> <pre><code>@abstractmethod\ndef load_output(self, **kwargs):\n\"\"\"\n    Reads and load into `.output` the outputs generated by the code.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.plot","title":"<code>plot(y=[], x=None, xlim=None, ylim=None, ylim2=None, y2=[], nice=True, include_layout=True, include_labels=False, include_particles=True, include_legend=True, return_figure=False)</code>  <code>abstractmethod</code>","text":"<p>Plots output multiple keys.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>list</code> <p>List of keys to be displayed on the Y axis</p> <code>[]</code> <code>x</code> <code>str</code> <p>Key to be displayed as X axis</p> <code>None</code> <code>xlim</code> <code>list</code> <p>Limits for the X axis</p> <code>None</code> <code>ylim</code> <code>list</code> <p>Limits for the Y axis</p> <code>None</code> <code>ylim2</code> <code>list</code> <p>Limits for the secondary Y axis</p> <code>None</code> <code>y2</code> <code>list</code> <p>List of keys to be displayed on the secondary Y axis</p> <code>[]</code> <code>nice</code> <code>bool</code> <p>Whether or not a nice SI prefix and scaling will be used to make the numbers reasonably sized. Default: True</p> <code>True</code> <code>include_layout</code> <code>bool</code> <p>Whether or not to include a layout plot at the bottom. Default: True</p> <code>True</code> <code>include_labels</code> <code>bool</code> <p>Whether or not the layout will include element labels. Default: False</p> <code>False</code> <code>include_particles</code> <code>bool</code> <p>Whether or not to plot the particle statistics as dots. Default: True</p> <code>True</code> <code>include_legend</code> <code>bool</code> <p>Whether or not the plot should include the legend. Default: True</p> <code>True</code> <code>return_figure</code> <code>bool</code> <p>Whether or not to return the figure object for further manipulation. Default: True</p> <code>False</code> <code>kwargs</code> <code>dict</code> <p>Extra arguments can be passed to the specific plotting function.</p> required <p>Returns:</p> Name Type Description <code>fig</code> <code>matplotlib.pyplot.figure.Figure</code> <p>The plot figure for further customizations or <code>None</code> if <code>return_figure</code> is set to False.</p> Source code in <code>lume/base.py</code> <pre><code>@abstractmethod\ndef plot(self, y=[], x=None, xlim=None, ylim=None, ylim2=None, y2=[], nice=True,\n         include_layout=True, include_labels=False, include_particles=True, include_legend=True,\n         return_figure=False):\n\"\"\"\n    Plots output multiple keys.\n\n    Parameters\n    ----------\n    y : list\n        List of keys to be displayed on the Y axis\n    x : str\n        Key to be displayed as X axis\n    xlim : list\n        Limits for the X axis\n    ylim : list\n        Limits for the Y axis\n    ylim2 : list\n        Limits for the secondary Y axis\n    y2 : list\n        List of keys to be displayed on the secondary Y axis\n    nice : bool\n        Whether or not a nice SI prefix and scaling will be used to\n        make the numbers reasonably sized. Default: True\n    include_layout : bool\n        Whether or not to include a layout plot at the bottom. Default: True\n    include_labels : bool\n        Whether or not the layout will include element labels. Default: False\n    include_particles : bool\n        Whether or not to plot the particle statistics as dots. Default: True\n    include_legend : bool\n        Whether or not the plot should include the legend. Default: True\n    return_figure : bool\n        Whether or not to return the figure object for further manipulation.\n        Default: True\n    kwargs : dict\n        Extra arguments can be passed to the specific plotting function.\n\n    Returns\n    -------\n    fig : matplotlib.pyplot.figure.Figure\n        The plot figure for further customizations or `None` if `return_figure` is set to False.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.reset","title":"<code>reset()</code>","text":"<p>Reset this object to its initial state.</p> Source code in <code>lume/base.py</code> <pre><code>def reset(self):\n\"\"\"\n    Reset this object to its initial state.\n    \"\"\"\n    super().reset()\n    # Clear this\n    if self._use_temp_dir:\n        self._base_path = None\n        self._configured = False\n</code></pre>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.setup_workdir","title":"<code>setup_workdir(workdir, cleanup=True)</code>","text":"<p>Set up the work directory if <code>use_temp_dir</code> is set.</p> <p>workdir and use_temp_dir: Set up temorary directory inside workdir</p> <p>Parameters:</p> Name Type Description Default <code>workdir</code> <code>str</code> <p>The directory name.</p> required <code>cleanup</code> <code>bool</code> <p>Whether or not to remove the directory at exit. Defaults to True.</p> <code>True</code> Source code in <code>lume/base.py</code> <pre><code>def setup_workdir(self, workdir, cleanup=True):\n\"\"\"\n    Set up the work directory if `use_temp_dir` is set.\n\n    workdir and use_temp_dir: Set up temorary directory inside workdir\n\n    Parameters\n    ----------\n    workdir : str\n        The directory name.\n    cleanup : bool\n        Whether or not to remove the directory at exit. Defaults to True.\n    \"\"\"\n\n    if not cleanup:\n         warnings.warn(\"cleanup option has been removed\", DeprecationWarning)\n\n    # Set paths\n    if self._use_temp_dir:\n        # Need to attach this to the object. Otherwise it will go out of scope.\n        self._tempdir = tempfile.TemporaryDirectory(dir=workdir)\n        self._base_path = self._tempdir.name\n    elif workdir:\n        self._base_path = workdir\n    else:\n        # Work in place\n        self._base_path = self.original_path\n</code></pre>"},{"location":"api/command_wrapper/#lume.base.CommandWrapper.write_input","title":"<code>write_input(input_filename)</code>  <code>abstractmethod</code>","text":"<p>Write the input parameters into the file.</p> <p>Parameters:</p> Name Type Description Default <code>input_filename</code> <code>str</code> <p>The file in which to write the input parameters</p> required Source code in <code>lume/base.py</code> <pre><code>@abstractmethod\ndef write_input(self, input_filename):\n\"\"\"\n    Write the input parameters into the file.\n\n    Parameters\n    ----------\n    input_filename : str\n        The file in which to write the input parameters\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/tools/","title":"Tools","text":""},{"location":"api/tools/#lume.tools","title":"<code>lume.tools</code>","text":""},{"location":"api/tools/#lume.tools.NpEncoder","title":"<code>NpEncoder</code>","text":"<p>         Bases: <code>json.JSONEncoder</code></p> <p>Custom encoder to serialize Numpy data types.</p> <p>StackOverflow reference</p> Source code in <code>lume/tools.py</code> <pre><code>class NpEncoder(json.JSONEncoder):\n\"\"\"\n    Custom encoder to serialize Numpy data types.\n\n    [StackOverflow reference](https://stackoverflow.com/q/50916422)\n    \"\"\"\n    def default(self, obj):\n\"\"\"\n        \"\"\"\n        if isinstance(obj, np.integer):\n            return int(obj)\n        elif isinstance(obj, np.floating):\n            return float(obj)\n        elif isinstance(obj, np.ndarray):\n            return obj.tolist()\n        else:\n            return super(NpEncoder, self).default(obj)\n</code></pre>"},{"location":"api/tools/#lume.tools.execute","title":"<code>execute(cmd, cwd=None)</code>","text":"<p>Constantly print Subprocess output while process is running from: https://stackoverflow.com/questions/4417546/constantly-print-subprocess-output-while-process-is-running</p>"},{"location":"api/tools/#lume.tools.execute--example-usage","title":"Example usage:","text":"<pre><code>for path in execute([\"locate\", \"a\"]):\nprint(path, end=\"\")\n</code></pre> <p>Useful in Jupyter notebook</p> Source code in <code>lume/tools.py</code> <pre><code>def execute(cmd, cwd=None):\n\"\"\"\n\n    Constantly print Subprocess output while process is running\n    from: https://stackoverflow.com/questions/4417546/constantly-print-subprocess-output-while-process-is-running\n\n    # Example usage:\n        for path in execute([\"locate\", \"a\"]):\n        print(path, end=\"\")\n\n    Useful in Jupyter notebook\n\n    \"\"\"\n    popen = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True, cwd=cwd)\n    for stdout_line in iter(popen.stdout.readline, \"\"):\n        yield stdout_line \n    popen.stdout.close()\n    return_code = popen.wait()\n    if return_code:\n        raise subprocess.CalledProcessError(return_code, cmd)\n</code></pre>"},{"location":"api/tools/#lume.tools.execute2","title":"<code>execute2(cmd, timeout=None, cwd=None)</code>","text":"<p>Execute with time limit (timeout) in seconds, catching run errors.</p> Source code in <code>lume/tools.py</code> <pre><code>def execute2(cmd, timeout=None, cwd=None):\n\"\"\"\n    Execute with time limit (timeout) in seconds, catching run errors. \n    \"\"\"\n\n    output = {'error':True, 'log':''}\n    try:\n        p = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, timeout = timeout, cwd=cwd)\n      #  p = subprocess.run(' '.join(cmd), shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True, timeout = timeout)\n        output['log'] = p.stdout\n        output['error'] = False\n        output['why_error'] =''\n    except subprocess.TimeoutExpired as ex:\n        output['log'] = ex.stdout+'\\n'+str(ex)\n        output['why_error'] = 'timeout'\n    except:\n        output['log'] = 'unknown run error'\n        output['why_error'] = 'unknown'\n    return output    \n</code></pre>"},{"location":"api/tools/#lume.tools.find_executable","title":"<code>find_executable(exename=None, envname=None)</code>","text":"<p>Finds an executable from a given name or environmental variable.</p> <p>If neither are files, the path will be searched for exename</p> Source code in <code>lume/tools.py</code> <pre><code>def find_executable(exename=None, envname=None):\n\"\"\"\n    Finds an executable from a given name or environmental variable.\n\n    If neither are files, the path will be searched for exename\n\n    \"\"\"\n\n    # Simply return if this exists\n    if exename and os.path.isfile(exename):\n        assert os.access(exename, os.X_OK), f'File is not executable: {exename}'\n        return full_path(exename)\n\n    envexe = os.environ.get(envname)\n    if envexe and os.path.isfile(envexe):\n        assert os.access(envexe, os.X_OK), f'File is not executable: {envexe}'\n        return full_path(envexe)\n\n    if not exename and not envname:\n         raise ValueError('No exename or envname ')\n\n    # Start searching\n    search_path = []\n    #search_path.append(os.environ.get(envname))\n    search_path.append(os.getcwd())\n    search_path.append(os.environ.get('PATH'))\n    search_path_str = os.pathsep.join(search_path)\n    bin_location = shutil.which(exename, path=search_path_str)\n\n    if bin_location and os.path.isfile(bin_location):\n        return full_path(bin_location)\n\n    raise ValueError(f'Could not find executable: exename={exename}, envname={envname}')\n</code></pre>"},{"location":"api/tools/#lume.tools.fingerprint","title":"<code>fingerprint(keyed_data, digest_size=16)</code>","text":"<p>Creates a cryptographic fingerprint from keyed data. Used JSON dumps to form strings, and the blake2b algorithm to hash.</p> <p>Parameters:</p> Name Type Description Default <code>keyed_data</code> <code>dict</code> <p>dict with the keys to generate a fingerprint</p> required <code>digest_size</code> <code>int, optional</code> <p>Digest size for blake2b hash code, by default 16</p> <code>16</code> <p>Returns:</p> Type Description <code>str</code> <p>The hexadecimal digest</p> Source code in <code>lume/tools.py</code> <pre><code>def fingerprint(keyed_data, digest_size=16):\n\"\"\"\n    Creates a cryptographic fingerprint from keyed data.\n    Used JSON dumps to form strings, and the blake2b algorithm to hash.\n\n    Parameters\n    ----------\n    keyed_data : dict\n        dict with the keys to generate a fingerprint\n    digest_size : int, optional\n        Digest size for blake2b hash code, by default 16\n\n    Returns\n    -------\n    str\n        The hexadecimal digest\n    \"\"\"\n    h = hashlib.blake2b(digest_size=digest_size)\n    for key in sorted(keyed_data.keys()):\n        val = keyed_data[key]\n        s = json.dumps(val, sort_keys=True, cls=NpEncoder).encode()\n        h.update(s)\n    return h.hexdigest()\n</code></pre>"},{"location":"api/tools/#lume.tools.full_path","title":"<code>full_path(path)</code>","text":"<p>Helper function to expand enviromental variables and return the absolute path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>A path possibly containing environment variables and user (~) shortcut</p> required <p>Returns:</p> Type Description <code>str</code> <p>The expanded absolute path</p> Source code in <code>lume/tools.py</code> <pre><code>def full_path(path):\n\"\"\"\n    Helper function to expand enviromental variables and return the absolute path\n\n    Parameters\n    ----------\n    path : str\n        A path possibly containing environment variables and user (~) shortcut\n\n    Returns\n    -------\n    str\n        The expanded absolute path\n    \"\"\"\n    return os.path.abspath(os.path.expanduser(os.path.expandvars(path)))\n</code></pre>"},{"location":"api/tools/#lume.tools.make_executable","title":"<code>make_executable(path)</code>","text":"<p>Makes a file executable.</p> <p>https://stackoverflow.com/questions/12791997/how-do-you-do-a-simple-chmod-x-from-within-python</p> Source code in <code>lume/tools.py</code> <pre><code>def make_executable(path):\n\"\"\"\n    Makes a file executable.\n\n    https://stackoverflow.com/questions/12791997/how-do-you-do-a-simple-chmod-x-from-within-python\n    \"\"\"\n    mode = os.stat(path).st_mode\n    mode |= (mode &amp; 0o444) &gt;&gt; 2    # copy R bits to X\n    os.chmod(path, mode)\n</code></pre>"},{"location":"api/tools/#lume.tools.native_type","title":"<code>native_type(value)</code>","text":"<p>Converts a numpy type to a native python type. See: https://stackoverflow.com/questions/9452775/converting-numpy-dtypes-to-native-python-types/11389998</p> Source code in <code>lume/tools.py</code> <pre><code>def native_type(value):\n\"\"\"\n    Converts a numpy type to a native python type.\n    See:\n    https://stackoverflow.com/questions/9452775/converting-numpy-dtypes-to-native-python-types/11389998\n    \"\"\"\n    return getattr(value, 'tolist', lambda: value)()   \n</code></pre>"}]}